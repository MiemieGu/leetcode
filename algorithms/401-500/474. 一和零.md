背包问题

## 动态规划

1. 递归代码简单，出错后不容易调试，面试可以用，思路简单，递归太深，容易超时
2. 数组容易调试，推荐比赛使用

## 递归写法超时

    ```
/**
 * @param {string[]} strs
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var findMaxForm = function (strs, m, n) {
    let A = new Array(strs.length)
    for (let i = 0; i < strs.length; i++) {
        A[i] = [0, 0]
        for (let c of strs[i]) {
            if (c === '1') {
                A[i][1]++
            } else {
                A[i][0]++
            }
        }
    }


    let cache = {}

    function dp(i, m, n) {

        if (cache[[i, m, n].join(',')]) {
            return cache[[i, m, n].join(',')]
        }
        if (i > 0 && (m < A[i][0] || n < A[i][1])) {
            cache[[i - 1, m, n].join(',')] = dp(i - 1, m, n)
            return cache[[i - 1, m, n].join(',')]
        }
        if (m == 0 && n == 0) {
            cache[[i, m, n].join(',')] = 0
            return 0
        }
        if (i < 0) {
            cache[[i, m, n].join(',')] = 0
            return 0
        }

        if (i === 0) {
            if (m < A[i][0] || n < A[i][1]) {
                cache[[i, m, n].join(',')] = 0
                return 0
            } else if (m >= A[i][0] && n >= A[i][1]) {
                cache[[i, m, n].join(',')] = 1
                return 1
            } else {
                console.log('异常 else', i, A[i], m, n)
            }
        }


        let s1 = dp(i - 1, m, n)
        let s2 = dp(i - 1, m - A[i][0], n - A[i][1])
        // console.log('<<<', i, i - 1, A[i], m, n, s1, s2)
        cache[[i - 1, m, n].join(',')] = s1
        cache[[i - 1, m - A[i][0], n - A[i][1]].join(',')] = s2
        cache[[i, m, n].join(',')] = Math.max(s1, s2 + 1)
        return cache[[i, m, n].join(',')]
    }

    return dp(A.length - 1, m, n)

};
```

59 / 63 个通过测试用例。状态：超出时间限制

## 不用递归，使用数组优化

```
/**
 * @param {string[]} strs
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var findMaxForm = function (strs, m, n) {

    let memo = new Array(m + 1)
    for (let i = 0; i < m + 1; i++) {
        memo[i] = new Array(n + 1).fill(0)
    }
    for (let i = 0; i < strs.length; i++) {

        let [numZeroes, numOnes] = [0, 0];
        for (let c of strs[i]) {
            if (c === '1') {
                numOnes++
            } else {
                numZeroes++
            }
        }

        for (let i = m; i >= numZeroes; i--) {
            for (let j = n; j >= numOnes; j--) {
                memo[i][j] = Math.max(memo[i][j], memo[i - numZeroes][j - numOnes] + 1);
            }
        }
    }
    return memo[m][n]
};
```

