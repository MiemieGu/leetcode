给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。

示例:

输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/palindrome-partitioning
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

分治、回溯、动态规划

1. 动态规划求子问题 f(i, j)表示i到j是否回文子串
2. dfs求所有可能性


----

**子问题**

动态规划判断是否回文

```cgo
// 是否回文串；动态规划思路
// 对于字符串 s。
// 用 dp[i][j] 表示 s[i，j] 是否是回文串。
// 然后有 dp[i][j] = s[i] == s[j] && dp[i+1][j-1]
func IsPalindrome(s string) [][]bool {
	dp := make([][]bool, len(s))
	for i := 0; i < len(s); i++ {
		dp[i] = make([]bool, len(s))
	}
	for k := 1; k <= len(s); k++ { // 长度k
		for i := 0; i <= len(s)-k; i++ {
			j := i + k - 1;
			dp[i][j] = s[i] == s[j] && (k < 3 || dp[i+1][j-1]);
		}
	}
	return dp
}
```


----

no ac

```javascript
function isPalindrome(s) {
    let dp = new Array(s.length)
    for (let i = 0; i < dp.length; i++) {
        dp[i] = new Array(s.length).fill(false)
    }
    for (let l = 1; l <= s.length; l++) {
        for (let i = 0; i <= s.length - l; i++) {
            let j = i + l - 1
            dp[i][j] = s[i] == s[j] && (l < 3 || dp[i + 1][j - 1])
        }
    }
    return dp
}

var partition = function (s) {
    let dp = isPalindrome(s)
    let ans = []
    let startPath = []

    function dfs(path) {
        path = [...path]
        let start = path.length == 0 ? 0 : path[path.length - 1] + 1
        if (start == s.length - 1) {
            path.push(start)
            ans.push(path)
            return
        }

        for (let j = start; j < s.length; j++) {
            if (dp[start][j] == true) {
                path.push(j)
                dfs(path)
                path.pop()
            }
        }
    }

    dfs(startPath)

    if (s.length > 1 && dp[0][s.length - 1] == true) ans.push([s.length - 1])
    let r = []
    for (let item of ans) {
        let start = -1
        let row = []
        for (let end of item) {
            row.push(s.substr(start + 1, end - start))
            start = end
        }
        r.push(row)
    }

    return r
};
```

