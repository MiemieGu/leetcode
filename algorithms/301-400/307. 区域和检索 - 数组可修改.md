给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。

update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。

示例:

Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8
说明:

数组仅可以在 update 函数下进行修改。
你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/range-sum-query-mutable
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

----

相似题目

303. 区域和检索 - 前缀和求解，时间复杂度O(N)

----

线段树

----

```javascript
/**
 * @param {number[]} nums
 */
var NumArray = function (nums) {
    this.N = nums.length
    this.segmentTree = new Array(this.N << 1)
    for (let i = this.N; i < 2 * this.N; i++) {
        this.segmentTree[i] = nums[i - this.N]
    }

    for (let i = this.N - 1; i > 0; i--) {
        this.segmentTree[i] = this.segmentTree[i << 1] + this.segmentTree[i << 1 | 1]
    }
};

/**
 * @param {number} i
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function (i, val) {
    i += this.N
    this.segmentTree[i] = val
    while (i > 0) {
        this.segmentTree[i >> 1] = this.segmentTree[i] + this.segmentTree[i ^ 1]
        i = i >> 1
    }
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function (i, j) {
    let sum = 0
    i += this.N
    j += this.N
    while (i <= j) {
        if ((i & 1) == 1) {
            sum += this.segmentTree[i++]
        }
        if ((j & 1) == 0) {
            sum += this.segmentTree[j--]
        }
        i = i >> 1
        j = j >> 1
    }
    return sum
};
```
