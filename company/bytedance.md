


## 855. 立方体塔

小方有w个白色立方体和b个黑色立方体，现在小方想把它们堆成一个立方体塔。

一座高度为h的立方体塔，最底层有h个立方体，每往上一层，所需立方体减一，直到最高层只需要一个立方体。

为了让这座塔看起来美观，小方希望，每一层都只能用一种颜色的立方体。

小方希望把这座塔叠的尽可能高，因此他想知道塔的最大高度是多少，以及这个高度的立方体塔能有几种。

两种立方体塔，当且仅当至少有一层的颜色是不同的，则被认为是不同的。

输入格式
共一行，包含两个整数w和b。

输出格式
共一行，包含两个整数h和c，分别表示最高塔的高度以及此高度塔的种类数。

因为种类数可能较多，请将c对109+7取模后的值输出。

数据范围
0≤w,b≤105
输入样例：
1 1
输出样例：
1 2

https://www.acwing.com/problem/content/857/

**思路**

- 求最高层数

总的小方块数

1 + 2 + 3 + 4 + 。。。 + h

= (1 + h) * h <= w + b

理论高度上限h满足：(1 + h) * h <= w + b

理论高度上限一定可以取到，w 可以取 0 ~ w+b个，那么无论w取多少，w都可以堆上去，剩下的用b来堆

用数学归纳法可以证明

- 求方案数

```cgo
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010,mod = 1e9 + 7;

int f[N];

int main(){
    int n ,m ;
    scanf("%d%d",&n, &m);
    
    int h = 1;
    while (h*(h+1)/2 <= n+m) h++;
    h--;
    
    f[0] = 1;
    for (int i = 1; i <= h;i++){
        for (int j = n; j >=i; j--){
            f[j] = (f[j] + f[j -i]) %mod;
        }
    }
    
    int res = 0;
    for (int i = 0; i<=n; i++){
        if (h * (h+1) /2 - i <= m){
            res = (res + f[i]) %mod;
        }
    }
    
    printf("%d %d\n", h, res);
    return 0;
}
```







