## 61. 旋转链表

思路

1. 第一遍遍历，得到链表的长度n，连接尾部和头部
2. 第二遍遍历，移动到 n - k % n 的位置，断开上一个节点与这个节点的连接

```javascript
const rotateRight = (head, k) => {
  if (!head) return null
  let curr = head, prev = null, n = 0
  while (curr) {
    n++
    if (!curr.next) {
      curr.next = head
      break
    }
    curr = curr.next
  }
  k = k % n
  while (k++ < n) {
    k === n && (prev = head)
    head = head.next
  }
  prev.next = null
  return head
}
```

## 86. 分隔链表

思路

1. 初始化两个链表p, q,保存头结点phead, qhead
2. 遍历原链表，比x小的，拼到p,比x大的，拼到q
3. 拼接两个链表；如果phead是空，返回qhead；否则，返回p.next = qhead,返回phead

```javascript
var partition = function (head, x) {
    if (head == null) return null
    let p = q = phead = qhead = null, curr = head
    while (curr) {
        if (curr.val < x) {
            if (p == null) {
                p = new ListNode(curr.val);
                phead = p;
            } else {
                p.next = new ListNode(curr.val);
                p = p.next;
            }
        }
        if (curr.val >= x) {
            if (q == null) {
                q = new ListNode(curr.val);
                qhead = q;
            } else {
                q.next = new ListNode(curr.val);
                q = q.next;
            }
        }
        curr = curr.next
    }

    if (p) {
        p.next = qhead
    } else {
        return qhead
    }
    return phead
};

```
---

思路二

- 初始化返回值ans = null，用于保存头结点的位置
- 初始化一个链表q，用于保存大于等于x的元素,头结点qhead
- 遍历链表，如果当前元素curr大于等于x，前置节点prev = curr.next; curr.next=null; q.next = new List(curr.val);q=q.next; 如果当前元素curr小于x, ans = curr
- 拼接ans + qhead
- 返回ans










