# 位运算

## 基本运算

与  a & b

或 a | b

非 ~a

异或 a ^ b

## 不使用额外空间交换两个元素

异或运算

```code
a = a ^ b
b = a ^ b
a = a ^ b
```

加减法交换

```code
a = a + b
b = a - b
a = a - b
```

## 除以2或2的幂

x >> 1

x >> k

### LowBit（低位运算）

获取某个二进制数的最低位1

`x & -x`

-x 的值，其实就是在x的值的基础上进行按位取反(~x)之后在增加1所得

x & -x == x & (~x + 1)

x 为偶数
我们都知道， 当一个奇数 + 1时， 表示的二进制数则会发生进位， 这样的话， 会产生一个连锁反应，也就是最低位的那些连续的1都会被清0, 如 :

`0000 0000 0111 1111 + 1 = 0000 0000 1000 0000`

如果一个偶数, 如 0000 0100 1110， 取反后的结果就变成了 1111 1011 0001，而当这个值 + 1之后由于发生了进位， 即

`1111 1011 0001 + 1 = 1111 1011 0010`

这个结果再与最初的值相与后， 只会有一位保留为1

`0000 0100 1110 & 1111 1011 0010 = 0000 0000 0010`

这个结果与最初的值又有什么关系呢？

很显然， 这个值的与原值的末位0的个数是一致的， 哈哈， 要不要多试几个不一样的偶数来验正一下呢？
也就是说， 如果一个偶数， 在执行 x & -x的操作的时候， 最后结果肯定有如下两个特征

- 这个结果只有一位值是1， 其他位均是0
- 这个值的末位0的个数与原值保持一致

那这是个什么数呢？ 哈哈， 仔细一想， 这个原值肯定是能被结果值整除的， 而这个结果值又是2^ n， 那我们就可以描述成，

当一个偶数与它的负值相与时， 结果是能整除这个偶数的最大的2的幂, 即： `m = n & -n , 则 n % m = 0, 且 m = 2 ^ k`

x 为奇数

x 为奇数时就比较简单了， 因为奇数取反后的值一定是偶数， 而偶数的值 + 1之后， 并不会影响进位，
而 x与其取反的数相与结果肯定是0 ，但是由于相与的数是取反后再+ 1的值(肯定是个奇数)， 也就是说， 只有最后一位有翻转，所以只有最后一位都是1， 相与结果仍旧是1， 而其他位所有的只都是相反值， 相与必为0 , 所以结论是

如果是x是奇数， 那x & -x 的结果一定是1

最终结论

> 当一个数与其取负后的值相与，如果这个数是偶数，则结果是能整除这个偶数的最大的2的幂(即： m = n & -n , 则 n % m = 0, 且 m = 2 ^ k)， 如果这个数是奇数， 则结果必为1

用途： 一般可以用来获取某个二进制数的LowBit

## 将x的第k位置为1(k从0开始)

x |= (1 << y)

## 将x的第k位置为0(k从0开始)

x &= ~(1 << y)

## 判断一个数的第i位是不是1

`(x >> i) & 1` 或者 `x & (1 << i)`

## 力扣三题：只出现一次的数字

- [136.只出现一次的数字](../algorithm/101-200/136.%20只出现一次的数字.md)

    > 异或运算求解
- [137.只出现一次的数字II](../algorithm/101-200/137.%20只出现一次的数字%20II.md)

    > 三进制思路 +状态机
- [260.只出现一次的数字III](../algorithm/101-200/137.%20只出现一次的数字%20III.md)

    > 低位运算

## 练习题目


- [405.数字转换为十六进制数]()
- [1009.十进制整数的反码](../algorithm/1001-1100/1009.%20十进制整数的反码.md)
