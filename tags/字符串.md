# 字符串

## 字符串匹配算法

给定一个字符串s和模板串t，求t在s中出现的位置

### Brute-Force Algorithm（暴力算法 / 简单模式匹配）

### KMP算法

## 最长公共子序列

题目描述：求两个字符串s和t的最长公共子序列长度

### 动态规划

定义dp[i][j]表示以i位置结尾的s串和以j位置结尾的t串的最长公共子序列

则有状态转化方程

1. s[i-1] == t[i-1]时，dp[i][j] = dp[i-1][j-1] + 1
2. s[i-1] != t[i-1]时，dp[i][j] = max(dp[i-1][j], dp[i][j-1])

代码实现

```cpp
class Solution {
public:
    int longestCommonSubsequence(string s, string t) {
        vector<vector<int>> dp(s.size()+1, vector<int>(t.size()+1, 0));
        int ans = 0;
        for (int i = 1; i< dp.size(); i++){
            for (int j = 1; j < dp[0].size(); j++){
                if (s[i-1] == t[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                    ans = max(ans, dp[i][j]);
                }else {
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return ans;
    }
};
```

## 最长公共子串

求两个字符串的最长公共子串

问题：有两个字符串s和t，求出两个字符串中最长公共子串长度

比如：s=acbcbcef，t=abcbced，则str和str2的最长公共子串为bcbce，最长公共子串长度为5。

### 算法思路

1. 把两个字符串分别以行和列组成一个二维矩阵。
2. 比较二维矩阵中每个点对应行列字符中否相等，相等的话值设置为1，否则设置为0。
3. 通过查找出值为1的最长对角线就能找到最长公共子串。

针对于上面的两个字符串我们可以得到的二维矩阵如下

![common-sub-str](https://raw.githubusercontent.com/muyids/tuchuang/master/common-sub-str.jpeg)

从上图可以看到，str1和str2共有5个公共子串，但最长的公共子串长度为5。

为了进一步优化算法的效率，我们可以再计算某个二维矩阵的值的时候顺便计算出来当前最长的公共子串的长度，即某个二维矩阵元素的值由record[i][j]=1演变为record[i][j]=1 + record[i-1][j-1]，这样就避免了后续查找对角线长度的操作了。修改后的二维矩阵如下：

![common-sub-str2](https://raw.githubusercontent.com/muyids/tuchuang/master/common-sub-str2.jpeg)

### 动态规划

定义dp[i][j]表示以i位置结尾的s串和以j位置结尾的t串的最长公共子串长度

则有状态转化方程

1. s[i-1] == t[i-1]时，dp[i][j] = dp[i-1][j-1] + 1
2. s[i-1] != t[i-1]时，dp[i][j] = 0

代码实现

```cpp
class Solution {
public:
    int findLength(string s, string t) {
        vector<vector<int>> dp(s.size()+1, vector<int>(Btsize()+1, 0));
        int ans = 0;
        for (int i = 1; i < dp.size(); i++){
            for (int j = 1; j < dp[0].size(); j++){
                if (s[i-1] == t[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                    ans = max(ans, dp[i][j]);
                }
            }
        }
        return ans;
    }
};
```
