## dfs & 递归 & 回溯 & 剪枝

这四种算法结合使用，可以解决几类问题

- 棋盘搜索的问题，往往是在一个棋盘上查找最短路径、路径方案数
- 排列组合问题

## 递归代码模板

递归即为闭包

```go
func dfs(){
    doSomeThing()
    dfs()
    doAnotherThing()
}
```

回溯即附加条件后，递归下一状态之前，要回退上一步附加操作

```go
func dfs(){
    change()
    dfs()
    unchange()
}
```

dfs & 递归 & 回溯 & 剪枝 结合使用，代码模板

```template
for all router { // 遍历所有路径
    doCounter() // 统计结果
    doCut() // 剪枝
    func dfs(){ // 深搜
        doSomeThing()   // 搜索处理，保存当前状态等
        change()    // 当前棋盘变化
        dfs()       // 递归
        unchange()  // 回溯棋盘变化（恢复现场）
        doAnotherThing()
    }
}
```

## 适用于解决的问题特征

- 深度优先搜索经常用来处理数据量非常庞大的问题
    比如数独问题，用宽搜搜不完的
- 常用于解决树形问题
- 宽度优先搜索经常用来处理最短路径，或最短距离
- 深度搜索不一定等于递归，也可以用循环来实现
- 所谓回溯就是恢复初始状态（恢复现场）
    如果我们的状态是整个棋盘，就需要恢复现场，如果是某一个格子，就不需要恢复现场

## 经典问题

引入几个简单问题，帮助大家理解概念

- 递归经典问题：汉诺塔
- 回溯经典问题：八皇后

### 递归经典问题：汉诺塔

三座塔A, B, C，求移动的最小次数

分三步：

1.把上面的n-1，从A->B;
2.把最下面的盘子，从A->C;
3.把B上的n-1，从B->A;

递归求解

```javascript
function Hanoi(n){
    if (n == 1) return 1
    if (n == 2) return 3
    return 2*Hanoi(n-1) + 1 // 可以通过递推公式得到
}
```

拓展：

四座塔A, B, C, D, 求移动的最小次数

<https://www.acwing.com/problem/content/description/98/>

动态规划，递推求解

```cpp
#include <bits/stdc++.h>
using namespace std;
int d[21],f[21],i,j;
int main()
{
    for (i=1;i<=12;i++)
        d[i]=2*d[i-1]+1;
    memset(f,0x3f,sizeof(f));
    f[0]=0;
    for (i=1;i<=12;i++)
        for (j=0;j<i;j++)
            f[i]=min(f[i],2*f[j]+d[i-j]);
    for (i=1;i<=12;i++)
        cout<<f[i]<<endl;
}
```

所有递归问题都可以转化为递推求解，我的习惯是抽象为递推问题，求解

递归容易出现爆栈，而且一旦逻辑出错，定位问题的难度也要高于递推

## 回溯经典问题：八皇后问题

经典回溯案例；

参考[力扣51.N皇后](../algorithms/1-100/51.%20N皇后.md)

## 其他练习题

- [17.电话号码的字母组合](../algorithms/1-100/17.%20电话号码的字母组合.md)
- [37.解数独]()
- [79.单词搜索](../algorithms/1-100/79.%20单词搜索.md)
- [46.全排列]()
- [47.全排列 2]()
- [52.八皇后问题 II]()
- [78.子集]()
- [90.子集II]
- [131.分割回文串]()
- [216.组合数III]()
- [306.累加数]()
- [473.火柴拼正方形]()

### [78.子集]()

两种思路：bfs + 回溯；二进制法

### 90. 子集II

### [37.解数独]()

拓展:数据结构 Dancing Links

### 473. 火柴拼正方形

剪枝的经典题目,通过增加剪枝，极大优化宽搜效率
