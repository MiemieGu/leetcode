# 二叉树

## 二叉树的遍历

- 深度优先搜索
- 宽度优先搜索

### 深度优先遍历

bfs有 先序、中序、后序遍历

可以用递归和非递归方式实现

#### 先序遍历

遍历顺序：根左右

递归

```code
func dfs(root){
    visit(root)
    dfs(root.left)
    dfs(root.right)
}
```

代码实现

```cpp
class Solution {
private:
    vector<int > ans;
public:
    vector<int> preorderTraversal(TreeNode* root) {
        dfs(root);
        return ans;
    }
    void dfs(TreeNode* root){
        if (!root) return ;
        ans.push_back(root->val);
        dfs(root->left);
        dfs(root->right);
    }
};
```

非递归方式

用指针p表示当前位置，用一个来栈记录访问顺序

对于每一个当前节点p，先访问p, 然后右子树入栈，然后访问左子树

```template
栈S;
p= root;
while(p || S不空){
    while(p){
        访问p节点；
        p的右子树入S;
        p = p的左子树;
    }
    p = S栈顶弹出;
}
```

代码实现

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        TreeNode* p = root;
        vector<TreeNode*> stk;
        while (p || !stk.empty()){
            while (p){
                ans.push_back(p->val);
                stk.push_back(p->right);
                p = p->left;
            }
            p = stk.back();
            stk.pop_back();
        }
        return ans;
    }
};
```

### 中序遍历

中序遍历：左根右

递归方式

```code
func dfs(root){
    dfs(root.left)
    visit(root)
    dfs(root.right)
}
```

非递归方式

思路：

先把左子树都进栈，依次出栈，访问左子树，出栈过程把右子树都入栈，
这样访问的顺序就是 左 根 右；

用一个指针p标记当前游标，一个栈保存访问顺序

对于每一个当前节点p，先把左节点全部入栈，在出栈的过程中，依次访问根节点，右子树

```template
栈S;
p = root;
while(p || S不空){
    while(p){
        p入S;
        p = p的左子树;
    }
    p = S.top 出栈;
    访问p;
    p = p的右子树;
}
```


```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if (!root) return {};
        vector<TreeNode*> stk = {};
        vector<int> ans;
        TreeNode* p = root;
        while (p || !stk.empty()){
            while(p){
                stk.push_back(p);
                p = p->left;
            }
            p = stk.back();
            ans.push_back(p->val);
            stk.pop_back();
            p = p->right;
        }
        return ans;
    }
};
```

### 后序遍历

#### 递归思路

```javascript
var postorderTraversal = function(root) {
    let ans = []
    function dfs(root){
        if (!root) return
        dfs(root.left)
        dfs(root.right)
        ans.push(root.val)
    }
    dfs(root)
    return ans
};
```

#### 迭代思路

先得到根右左，然后逆序得到左右根

得到根右左的过程类似先序得到根左右，先把右子树访问完，把左子树压栈

```algorithm
栈S;
p= root;
while(p || S不空){
    while(p){
        访问p节点；
        p的左子树入S;
        p = p的右子树;
    }
    p = S栈顶弹出;
}
结果序列逆序;
```

代码实现：

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        vector<TreeNode*> stk;
        TreeNode* p = root;
        while (p || !stk.empty()){
            while(p){
                ans.push_back(p->val);
                stk.push_back(p->left);
                p = p->right;
            }
            p = stk.back();
            stk.pop_back();
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

### 二叉树的层遍历（广度优先遍历）

## 题目列表

- [94.二叉树的中序遍历](../algorithm/1-100/94.%20二叉树的中序遍历.md)
- [98.验证二叉搜索树](../algorithm/1-100/98.%20验证二叉搜索树.md)
- [101.对称二叉树(镜像二叉树)](../algorithm/101-200/101.%20对称二叉树(镜像二叉树).md)
- [105.从前序与中序遍历序列构造二叉树](TODO)
- [108.将有序数组转换成二叉搜索树](../algorithm/101-200/108.%20将有序数组转换成二叉搜索树.md)
- [109.有序链表转换二叉搜索树](TODO)
- [124.二叉树中的最大路径和](TODO)
- [129.求根到叶子节点数字之和](TODO)
- [173.二叉搜索树迭代器](TODO)
- [235.二叉搜索树的最近公共祖先](TODO)
- [236.二叉树的最近公共祖先](../algorithm/201-300/236.%20二叉树的最近公共祖先.md)
- [437.路径总和III](../algorithm/401-500/437.%20路径总和%20III.md)
- [513.找树左下角的值](../algorithm/501-600/513.%20找树左下角的值.md)
- [538.把二叉搜索树转换为累加树](TODO)
- [543.二叉树的直径](../algorithm/501-600/543.%20二叉树的直径.md)
- [863.二叉树中所有距离为K的结点](../algorithm/801-900/863.%20二叉树中所有距离为%20K%20的结点.md)
- [889.根据前序和后序遍历构造二叉树](../algorithm/801-900/889.%20根据前序和后序遍历构造二叉树.md)
- [951.翻转等价二叉树](../algorithm/901-1000/951.%20翻转等价二叉树.md)
- [958.二叉树的完全性检验](../algorithm/901-1000/958.%20二叉树的完全性检验.md)
- [979.在二叉树中分配硬币](../algorithm/901-1000/979.%20在二叉树中分配硬币.md)
- [1008.先序遍历构造二叉树](../algorithm/1001-1100/1008.%20先序遍历构造二叉树.md)

## 二叉搜索树

二叉搜索树的性质：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

判断条件：

1. 中序遍历是递增序列的二叉树一定是二叉搜索树，可以利用中序遍历是否有序判断是否二叉搜索树
1. 根节点大于所有左子树节点，如果根节点大于左子树的最大值节点即可，因为左子树的最大值位于左子树最右边的节点，所以只要根节点 > 左子树的最右节点即可；同理，根节点 < 右子树的最左节点；

练习题目

- 530.二叉搜索树的最小绝对差
    > 利用性质：二叉搜索树的中序遍历是递增序列
- 二叉搜索树中第k小的元素
    > 利用性质：二叉搜索树的中序遍历是递增序列，遍历到第k个元素返回
- 二叉搜索树中的众数
    > 利用性质：二叉搜索树的中序遍历是递增序列
- 二叉搜索树的范围和
    > 利用性质：二叉搜索树的中序遍历是递增序列

### 94. 二叉树的中序遍历

### [98.验证二叉搜索树](../algorithm/1-100/98.%20验证二叉搜索树.md)

深度优先搜索

左孩子 < 根，右孩子 > 根
左子树的最右孩子 < 根，右子树的最左孩子 > 根

### 101. 对称二叉树(镜像二叉树)

### 105. 从前序与中序遍历序列构造二叉树

### 108. 将有序数组转换成二叉搜索树

二分法 + 递归实现

### 109. 有序链表转换二叉搜索树

这道题跟108很相似，只不过108是有序数组，可以用下标直接找到中点

对于链表，可以通过快慢指针来求解

### 124. 二叉树中的最大路径和

### 129. 求根到叶子节点数字之和

### 173. 二叉搜索树迭代器

### 235. 二叉搜索树的最近公共祖先

二叉搜索树的最近公共祖先，一定位于两个节点的闭区间里

### 236. 二叉树的最近公共祖先

### 513.找树左下角的值

深搜，记录层数，求最大层数第一个元素

### 538. 把二叉搜索树转换为累加树

### 543. 二叉树的直径

### 979.在二叉树中分配硬币

深搜，后序遍历，差值往根节点加，记录移动次数
