[toc]

- 129. 求根到叶子节点数字之和
- 538. 把二叉搜索树转换为累加树

---

## 98. 验证二叉搜索树

### 递归

分析

递归所有节点满足，二叉树的左孩子 < 根, 右孩子 > 根

代码

```
var isValidBST = function(root) {

    function dfs(root){
        if (root == null ){
            return true
        }
        if (root.left){
            if (root.left.val >= root.val) return false 
        }
        if (root.right){
            if (root.right.val <= root.val) return false
        }

        return dfs(root.left) && dfs(root.right)
    }

    return dfs(root)
};
```

但是这样也不一定正确，如下面的case就不通过

[10,5,15,null,null,6,20] 返回true,期望false

实际上BST，需要整个右子树都大于根，整个左子树都小于根

前面已经判断了，右孩子一定大于根，左孩子一定小于根；

需要再附加条件：**任意节点的值必须大于其左子树的最右节点；同时小于右子树的最左节点。从根节点开始检查，一旦发现不满足则返回false。**
 
整理代码

```javascript
var isValidBST = function(root) {

    function dfs(root){
        if (root == null ){
            return true
        }
        if (root.left){
            if (root.left.val >= root.val) return false 
            let rightest = getRightest(root.left)
            if (rightest && root.val <= rightest.val) return false

        }
        if (root.right){
            if (root.right.val <= root.val) return false
            let leftest = getLeftest(root.right)
            if (leftest && root.val >= leftest.val) return false
        }

        return dfs(root.left) && dfs(root.right)
    }

    function getRightest(node){
        while (node && node.right) node = node.right
        return node
    }

    function getLeftest(node){
        while (node && node.left) node = node.left
        return node
    }

    return dfs(root)
};
```

自上往下递归，传入当前子树所有值应该在的区间

		x [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]
	y		z
m	n		p	q

y取值 [Number.MIN_SAFE_INTEGER, x-1]
z取值 [x+1, Number.MAX_SAFE_INTEGER]
依次递推

```
var isValidBST = function(root) {
    function dfs(root, low, high){
        if (root == null) return true
        if (root.left && root.left.val >= root.val)return false
        if (root.right && root.right.val <= root.val)return false
        if (root.left && root.left.val < low) return false
        if (root.right && root.right.val > high) return false
        return dfs(root.left, low, root.val-1) && dfs(root.right, root.val+1, high)
    }
    return dfs(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)
};

```
### 中序遍历

```javascript
var isValidBST = function(root) {
    var queue = []
    function dfs(root){
        if (!root) return
        if (root.left) dfs(root.left)
        if (root) queue.push(root.val)
        if (root.right) dfs(root.right)
    }

    dfs(root)
    
    for (let i =0; i< queue.length-1; i++){
        if (queue[i] >= queue[i+1]) return false
    }
    
    return true
};
```

## 129. 求根到叶子节点数字之和

## 94. 二叉树的中序遍历

### 递归

ans = []
func dfs(root){
	if (root == null) return
	dfs(root.left)
	ans.push(root.val)
	dfs(root.right)
}

### 非递归

- 循环当前节点和栈元素
- 将当前节点左子树全部入栈
- 依次弹出栈顶元素
- 判断是否存在右孩子，如果存在p指向右孩子

```javascript
var inorderTraversal = function (root) {
    if (root == null) return []
    let stack = [], ans = []
    let p = root
    while (p || stack.length > 0) {
        while (p) {  // 左孩子全部入栈
            stack.push(p)
            p = p.left
        }
        // 弹出栈顶
        p = stack.pop()
        ans.push(p.val)
        p = p.right     // 指向右孩子
    }
    return ans
};
```

## 101. 对称二叉树(镜像二叉树)

对称二叉树满足条件

* 左右子树根节点相等
* 左子树的左孩子等于右子树的右孩子
* 左子树的右孩子等于右子树的左孩子

##### 递归

```
var isSymmetric = function (root) {
    if (root == null) return true
    function dfs(p, q) {
        if (p == null && q == null) return true
        if (p == null && q !== null || (p !== null && q == null)) return false
        if (p.val != q.val) return false
        return dfs(p.left, q.right) && dfs(p.right, q.left)
    }
    return dfs(root.left, root.right)
};
```

## 105. 从前序与中序遍历序列构造二叉树

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

##### 递归

```javascript
var buildTree = function(preorder, inorder) {
    if (preorder.length == 0){
        return null
    }
    var treeNode = new TreeNode(preorder[0])
    for (var i = 0; i< inorder.length; i++){
        if (preorder[0] == inorder[i]){
            treeNode.left = buildTree(preorder.slice(1, i+1), inorder.slice(0, i))
            treeNode.right = buildTree(preorder.slice(i+1, preorder.length), inorder.slice(i+1, preorder.length))
        }
    }
    return treeNode
};
```

## 108. 将有序数组转换成二叉搜索树

二分法 + 递归实现

## 109. 有序链表转换二叉搜索树

这道题跟108很相似，只不过108是有序数组，可以用下标直接找到中点

对于链表，可以通过快慢指针来求解

## 235. 二叉搜索树的最近公共祖先

二叉搜索树的最近公共祖先，一定位于两个节点的闭区间里

```javascript
var lowestCommonAncestor = function(root, p, q) {
    if (p.val > q.val) {
        [p, q] = [q, p]
    }
    if (root == null) return root
    if (root.val >= p.val && root.val <= q.val) return root
    if (root.val < p.val) return lowestCommonAncestor(root.right, p, q)
    if (root.val > q.val) return lowestCommonAncestor(root.left, p, q)  
};
```

## 236. 二叉树的最近公共祖先

* 如果root为根的子树包含p,q,则返回root
* 如果最近公共祖先不在左子树，返回右子树的最近公共祖先
* 如果最近公共祖先不在右子树，返回左子树的最近公共祖先
* 否则，返回根

```javascript
var lowestCommonAncestor = function(root, p, q) {
    if (root == null || root == p || root == q) return root
	let left = lowestCommonAncestor(root.left, p, q)
	let right = lowestCommonAncestor(root.right, p, q)
	if (!left) return right
	if (!right) return left
	return root
};
```

## 543. 二叉树的直径

* 枚举所有最高点
* 求所有最高点的最大值
* 所有最高点的最大值取MAX

某个最高点的最大值 = 左边最大深度 + 右边最大深度

```javascript
// 543. 二叉树的直径
var diameterOfBinaryTree = function (root) {
    if (!root) return 0
    let max = 0

    function dfs(root) {
        if (!root) return 0

        let left = dfs(root.left)
        let right = dfs(root.right)

        max = Math.max(max, left + right)
        return Math.max(left + 1, right + 1)
    }

    dfs(root)
    return max
};
```

## 124. 二叉树中的最大路径和

相似题目 543. 二叉树的直径

	x
y		z

* 枚举最高节点
* dfs(root)定义为从当前节点往下走的最大值
* 求 root + dfs(root.left) , root, root + dfs(root.right)三者的最大值
* dfs(root)为Math.max(0, root.val + Math.max(left, right)), 当子树路径和<0,则不取子树，最大值返回0

```javascript
var maxPathSum = function(root) {
    let ans = Number.MIN_SAFE_INTEGER
    function dfs(root){
        if (!root) return 0
        let left = dfs(root.left)
        let right = dfs(root.right)
        ans = Math.max(ans, root.val+left+right)
        return Math.max(0, root.val + Math.max(left, right))
    }
    dfs(root)
    return ans
};
```

## 173. 二叉搜索树迭代器

把中序遍历的非递归写法拆开

```javascript
var BSTIterator = function(root) {
    this.stack = []
    while (root){
        this.stack.push(root)
        root = root.left
    }
};

BSTIterator.prototype.next = function() {
    let p = this.stack.pop()
    let res = p.val
    p = p.right
    while(p){
        this.stack.push(p)
        p = p.left
    }
    return res
};

BSTIterator.prototype.hasNext = function() {
    return this.stack.length > 0
};
```


### 538. 把二叉搜索树转换为累加树




















