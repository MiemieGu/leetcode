Kruskal算法和Prim算法


生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。
最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。


Kruskal算法
此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。

1. 把图中的所有边按代价从小到大排序；
2. 把图中的n个顶点看成独立的n棵树组成的森林；
3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。
4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。



Prim算法
此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。

图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;
在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。
重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。

https://blog.csdn.net/a2392008643/article/details/81781766


最小生成树
概念：将给出的所有点连接起来（即从一个点可到任意一个点），且连接路径之和最小的图叫最小生成树。
数据结构：树形结构，或者说是直链型结构，因为当n个点相连，且路径和最短，那么将它们相连的路一定是n-1条
实现思路：将点分为在树中的点与不在树中的点，每次取出树中点的连接的最小路径，且该路径连接的点不在树中，然后将该路径连接的点加入树中，重复并进行路径更新，即松弛，当取出边达到n-1条时，树已建立。


难点：
1.如何找最小边
2.如何判断点在一个树
方法：
1.实现思路的再创新：在树中找最小边，不如直接将所有边存起来，进行遍历，看看这条边适不适合用来连接，此时会出现多个树的生成，但是没关系，最后还是会连接到一起的
2.当用一的方法实现了后，只需要进行每条边连接的两点是否在一树中的判断了，在一个树中，不用再连接了，因为前面比较小的边已经将他们连起来了，所以只需要用并查集进行两点是否同源的判断了
