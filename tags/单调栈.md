## 单调栈

单调栈分为单调递增栈和单调递减栈

单调递增栈即栈内元素保持单调递增的栈，同理单调递减栈即栈内元素保持单调递减的栈

单调栈里存的是数组元素的值或下标

## 两类问题

- 求某个元素两边第一个大于或小于此元素的解
- 求整个数列中满足单调性的最大跨度问题

一般数组中的单调性问题，题目中隐含最大或最小，第一个或离此元素最近的大于或小于元素的值，这类问题都可以考虑下，用单调栈是否可以求解

## 第一类：求某个元素两边第一个大于或小于此元素的解（较为常见）

单调栈的意义：可以在O(N)的时间复杂度，找到两边第一个小于或大于当前元素的值；

单调递增栈用于查找两边第一个小于当前元素的值，单调递减栈用于查找两边第一个大于当前元素的值

当前遍历的位置是最右边第一个元素，出栈元素为求解元素，单调栈内当前栈顶元素为左边第一个元素； // 右（遍历的） 中（出栈的） 左（当前栈顶的）

动画演示

![单调栈动画演示](https://raw.githubusercontent.com/muyids/tuchuang/master/monotone-stack.gif)

单调递增栈算法模板

```template
for 从左到右循环:
  if 栈不为空 && 栈顶元素 >= 当前元素:
    while 栈顶元素 >= 当前元素:
      出栈
  入栈
```

## 概念题（帮助理解单调栈的概念）

给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。

```case
数据范围
1≤N≤10^5 数列长度

输入
[3 4 2 7 5]

输出
[-1 3 -1 2 2]
```

找更小的数，用单增栈
找更大的数，用单减栈
找左边的，从左往右遍历
找右边的，从右往左遍历

---

### 思路

#### 暴力解法

```template
从左向右遍历数组
  当前位置向左遍历，直到遇到比他小的元素
```

时间复杂度 O(N^2),空间复杂度O(1)

#### 单调栈

```javascript
function singleStack(nums) {
  let stack = [],
    ans = new Array(nums.length).fill(0)

  for (let i = 0; i < nums.length; i++) {
    if (stack.length > 0 && stack[stack.length - 1] >= nums[i]) {
      while (stack[stack.length - 1] >= nums[i]) {
        stack.pop()
      }
    }
    if (stack.length == 0) ans[i] = -1
    else ans[i] = stack[stack.length - 1]
    stack.push(nums[i])
  }
  return ans
}
```

时间复杂度O(N)，空间复杂度O(N)

## 第二类：求整个数列中满足单调性的最大跨度问题

与第一类问题分清楚，选对模型，大多数时候我们说单调栈默认指的是第一类

算法思路：

以求解递增序列最大跨度为例

1. 定义单减栈，保存从左到右出现的最小值的下标
2. 从右到左遍历，当元素大于栈顶元素，出栈，更新最大跨度max；直到栈为空或移动到下标为max的位置，不需要再向左移动；

题目：

- [962.最大宽度坡](../algorithms/901-1000/962.%20最大宽度坡.md)
- [1124.表现良好的最长时间段](../algorithms/1101-1200/1124.%20表现良好的最长时间段.md)

---

单调栈练习题目

- [42.接雨水](../algorithms/1-100/42.%20接雨水.md)
- [84.柱状图中最大的矩形](../algorithms/1-100/84.%20柱状图中最大的矩形.md)
- [85.最大矩形](../algorithms/1-100/85.%20最大矩形.md)
- [239.滑动窗口最大值](../algorithms/201-300/239.%20滑动窗口最大值.md)
- [300.最长上升子序列](../algorithms/201-300/300.%20最长上升子序列.md)
- [402.移掉K位数字](../algorithms/1-100/402.%20移掉K位数字.md)
- [503.下一个更大元素 II](../algorithms/501-600/503.%20下一个更大元素%20II.md)
- [739.每日温度](../algorithms/701-800/739.%20每日温度.md)
- [768.最多能完成排序的块 II](../algorithms/701-800/768.%20最多能完成排序的块%20II.md)
- [901.股票价格跨度](../algorithms/901-1000/901.%20股票价格跨度.md)
- [962.最大宽度坡](../algorithms/901-1000/962.%20最大宽度坡.md)
- [1019.链表中的下一个更大节点](../algorithms/1001-1100/1019.%20链表中的下一个更大节点.md)
- [1124.表现良好的最长时间段](../algorithms/1101-1200/1124.%20表现良好的最长时间段.md)
- [1130.叶值的最小代价生成树](../algorithms/1101-1200/1130.%20叶值的最小代价生成树.md)

---

## [42.接雨水](../algorithms/1-100/42.%20接雨水.md)

单调递减栈

## [84.柱状图中最大的矩形](../algorithms/1-100/84.%20柱状图中最大的矩形.md)

单调递增栈

## [85.最大矩形](../algorithms/1-100/85.%20最大矩形.md)

在84题基础上可以求解

## [402.移掉K位数字](../algorithms/1-100/402.%20移掉K位数字.md)

贪心 + 单调递增栈，也是一道有趣的题目

## [503.下一个更大元素 II](../algorithms/501-600/503.%20下一个更大元素%20II.md)

求右边大于元素的最近的元素；单调递减栈 + 循环队列

## [739.每日温度](../algorithms/1-100/739.%20每日温度.md)

单调递减栈

## [768.最多能完成排序的块 II](../algorithms/1-100/768.%20最多能完成排序的块%20II.md)

特殊的单调递增栈，存储元素为两个边界

## [901.股票价格跨度](../algorithms/901-1000/901.%20股票价格跨度.md)

求大于元素的左边第一个元素和右边第一个元素的跨度

## [962.最大宽度坡](../algorithms/901-1000/962.%20最大宽度坡.md)

单调栈求整个序列最大跨度问题

跟1124类似

## [1019.链表中的下一个更大节点](../algorithms/1001-1100/1019.%20链表中的下一个更大节点.md)

求大于元素的右边最近的元素

## [1124.表现良好的最长时间段](../algorithms/1101-1200/1124.%20表现良好的最长时间段.md)

前缀和 + 单调栈

单调栈求整个序列最大跨度问题
