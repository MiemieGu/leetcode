
## 滑动窗口

滑动窗口算法的思路是这样：

1. 使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。
2. 先不断地增加 right 指针扩大窗口 [left, right]，直到窗口符合要求
3. 停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求。同时，每次增加 left，我们都要更新一轮结果。
4. 重复第 2 和第 3 步，直到 right 到达尽头。

这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。

注意:**滑动窗口、双指针、单调队列和单调栈经常配合使用**

## 代码模板

```code
int left = 0, right = 0;    // 左右指针

while (right < s.size()) {  // 右指针遍历直到边界
    window.add(s[right]);   // 右元素进窗口
    right++;                // 右指针移动

    while (!valid && left < right) {    // 不满足条件
        window.remove(s[left]); // 左元素出窗
        left++;                 // 左指针移动
    }
}
```

## 题目列表

- [3.无重复字符的最长子串](../algorithm/1-100/3.%20无重复字符的最长子串.md)
- [76.最小覆盖子串](../algorithm/1-100/100.%20最小覆盖子串.md)
- [159.至多包含两个不同字符的最长子串](../algorithm/101-200/159.%20至多包含两个不同字符的最长子串.md)
- [239.滑动窗口最大值](../algorithm/201-300/239.%20滑动窗口最大值.md)
- [438.找到字符串中所有字母异位词](../algorithm/401-500/438.%20找到字符串中所有字母异位词.md)
- [567.字符串的排列](../algorithm/501-600/567.%20字符串的排列.md)
- [1004.最大连续1的个数III](../algorithm/1001-1100/1004.%20最大连续1的个数%20III.md)

## 76. 最小覆盖子串

给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。

## 88. 合并两个有序数组

尾插法;三指针;

## 167. 两数之和 II - 输入有序数组

## 239.滑动窗口最大值

滑动窗口 + 单调递减栈

求区间范围的最大值，想到单调递减栈，要注意的是，每一次滑动，要进行右边元素的入栈；同时，左边下标移动，要判断栈底元素是否已经移除窗口

## 438. 找到字符串中所有字母异位词

## 567. 字符串的排列

给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。
