
滑动窗口、双指针、单调队列和单调栈

---

解题列表

- 567. 字符串的排列
- 1004. 最大连续1的个数 III

---

参考资料

https://www.bilibili.com/video/av64330434

https://note.youdao.com/ynoteshare1/index.html?id=270d3cd80b048c1074dcfa5b14ece4b4&type=note


---

伪代码模板

```gotemplate
int left = 0, right = 0;

while (right < s.size()) {
    window.add(s[right]);
    right++;
    
    while (valid) {
        window.remove(s[left]);
        left++;
    }
}
```

---

## 567. 字符串的排列

给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

---

思路

1. 遍历s1,用字典存储每个元素出现次数
2. s2滑动窗口，下标0到 s2.length - 1 - s1.length, 窗口长度为s1.length
	集合保存窗口里字符出现个数
3. 比较每个窗口出现的字符个数与1中字典存储的次数是否一致，不一致进行下一个窗口

```javascript
var checkInclusion = function (s1, s2) {
    let dict = {}
    for (let c of s1) {
        c in dict ? dict[c]++ : dict[c] = 1
    }
    let wind = {}
    for (let i = 0; i < s1.length; i++) {
        s2[i] in wind ? wind[s2[i]]++ : wind[s2[i]] = 1
    }

    function same(m1, m2) {
        for (let k in m1) {
            if (m1[k] != m2[k]) return false
        }
        return true
    }

    if (same(dict, wind)) return true

    for (let i = s1.length; i < s2.length; i++) {
        wind[s2[i - s1.length]]--
        wind[s2[i]] ? wind[s2[i]]++ : wind[s2[i]] = 1
        if (same(dict, wind)) return true
    }
    return false
};
```

## 167. 两数之和 II - 输入有序数组

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


numbers = [2, 7, 11, 15], target = 9

输出: [1,2]

---

双指针算法  

暴力 ---> 单调性？ --->  优化

##### 暴力

```javascript
var twoSum = function(numbers, target) {
    for (let i = 0; i< numbers.length - 1; i++){
        for (let j = i+1; j< numbers.length; j++){
            if (numbers[i] + numbers[j] == target){
                return [i+1, j+1]
            } else if (numbers[i] + numbers[j] > target){ // 剪枝
                 continue
            }
        }   
    }
};
```

##### 双指针 ，一次循环

```javascript
var twoSum = function (numbers, target) {
    for (let i = 0, j = numbers.length - 1; i < j;) {
        let sum = numbers[i] + numbers[j]
        if (sum > target) j--
        else if (sum < target) i++
        else return [i + 1, j + 1]
    }
};
```
---

## 88. 合并两个有序数组

尾插法;三指针;


## 76. 最小覆盖子串

给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。

示例：

输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-window-substring
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

暴力 ---> 单调性？ --->  优化

##### 暴力

for (int i = 0; i < s.size(); i++)
    for (int j = i + 1; j < s.size(); j++)
        if s[i:j] 包含 t 的所有字母:
            更新答案



滑动窗口算法的思路是这样：

1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。

2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。

3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。


伪码框架：

```cgo
string s, t;
// 在 s 中寻找 t 的「最小覆盖子串」
int left = 0, right = 0;
string res = s;

while(right < s.size()) {
    window.add(s[right]);
    right++;
    // 如果符合要求，移动 left 缩小窗口
    while (window 符合要求) {
        // 如果这个窗口的子串更短，则更新 res
        res = minLen(res, window);
        window.remove(s[left]);
        left++;
    }
}
return res;

```

## 438. 找到字符串中所有字母异位词



