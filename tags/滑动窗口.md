## 滑动窗口

滑动窗口算法的思路：

1. 使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。
2. 先不断地增加 right 指针扩大窗口 [left, right]，直到窗口符合要求
3. 停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求。同时，每次增加 left，我们都要更新一轮结果。
4. 重复第 2 和第 3 步，直到 right 到达尽头。

第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。
左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。

注意:

- 滑动窗口适用的题目一般具有单调性
- 滑动窗口、双指针、单调队列和单调栈经常配合使用

## 代码模板

```cpp
int left = 0, right = 0;    // 左右指针

while (right < s.size()) {  // 右指针遍历直到边界
    window.add(s[right]);   // 右元素进窗
    right++;                // 右指针移动

    while (valid(window) && left < right) {    // 窗口满足条件(优化窗口)
        window.remove(s[left]); // 左元素出窗
        left++;                 // 左指针移动；直到窗口不满足条件
    }
}
```

## 例题

### lc209. Minimum Size Subarray Sum(medium)

求N个正整数数组中连续子数组的和大于等于s的最小长度

分析：满足单调性，可以用滑动窗口，左右指针维护窗口，定义s记录窗口元素和

代码实现：

```cpp
class Solution {
public:
    int minSubArrayLen(int ss, vector<int>& nums) {
        int n = nums.size();
        int ans = n+1;
        int l = 0, r = 0, s = 0;
        while (r < n){
            s += nums[r++];
            while (l < r && s >= ss){
                ans = min(r -l , ans);
                s -= nums[l++];
            }
        }
        return ans == n + 1 ? 0: ans;
    }
};
```

扩展题目：

lc560. Subarray Sum Equals K

对于560题，The range of numbers in the array is [-1000, 1000]，数组中存在正数和负数，不满足单调性，我们考虑别的方法求解

## 练习

lc3. 无重复字符的最长子串(medium)
lc395. 至少有K个重复字符的最长子串(medium)
lc424. 替换后的最长重复字符(medium)
lc904. 水果成篮(medium)
lc239. 滑动窗口最大值(hard)
lc76. 最小覆盖子串(hard)
lc438. 找到字符串中所有字母异位词(medium)
lc480. 滑动窗口中位数(hard)
lc567. 字符串的排列
lc992. K个不同整数的子数组
lc995. K连续位的最小翻转次数
lc978. 最长湍流子数组
lc1040. 移动石子直到连续II
lc1052. 爱生气的书店老板
lc1074. 元素和为目标值的子矩阵数量
lc1208. 尽可能使字符串相等

### lc239. 滑动窗口最大值

滑动窗口 + 单调递减栈 + 双端队列 O(n)

求区间范围的最大值，想到单调递减栈，要注意的是，每一次滑动，要进行右边元素的入栈；同时，左边下标移动，要判断栈底元素是否已经移除窗口

### lc395. 至少有K个重复字符的最长子串

分治 + 滑动窗口
