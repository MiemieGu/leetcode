
# 并查集(Union-Find)

定义： 并查集（Union-Find Set），也称为不相交集数据结构（Disjointed Set Data Structure）。是指一系不相交的集合（Sets），提供合并（Union）和查找(Find)两种操作。

总结：一种用来解决集合查询合并的数据结构，支持O(1)find & O(1)union

- find(int i)

    > 判断是否属于同一集合
    > find(i)即查找I所归属的集合，通常我们使用find(i)和find(j)判断i和j是否连通，即是否属于同一个集合
- union(int i , int j)

    > 合并集合
    > 顾名思义，union方法即将I和J所在的两个集合连通起来，执行这个方法后，I所在集合和所有元素和J所在集合的所有元素都连通

## 代码模板

查找find

带路径压缩

```cpp
int find(int x) {
    if (father[x] == x){
        return x;
    }
    return father[x] = find(father[x]);
}
```

不带路径压缩

```cpp
int find(int x){
    if (father[x] == x){
        return x;
    }
    return find(father[x]);
}
```

比较路径压缩和无路径压缩代码区别；路径压缩:O(1)

合并Union

- 老大哥之间合并，跟小弟没关系

```cpp
void unionA(int a, int b){
    int root_a = find(a);
    int root_b = find(b);
    if (root_a != root_b){
        father[root_a] = root_b;
    }
}
```

## 另一种路径压缩实现

rank数组（了解）

```cpp
class Solution {
public:
    void makeSet(int n){
        vector<int> p(n, 0);
        for (int i = 0; i < n; i++) {
            p[i] = i;
        }
        vector<int> rank(n, 0);
    }

    int find(vector<int> &p, int x) {
        if (p[x] != x) {
            p[x] = find(p, p[x]);  //路径压缩
        }
        return p[x];
    }

    void unionSet(vector<int> &p, vector<int> &rank, int x, int y) {
        x = find(p, x);
        y = find(p, y);
        if (rank[x] < rank[y]) p[x]= y;
        else {
            p[y] = x;
            if (rank[x] == rank[y]) rank[x]++;
        }
    }
};
```

### 适用场景

1. Union-Find算法最常见的使用场景就是`动态连通（dynamic-connectivity）`

    > 在浩如烟海的数据中要判断两个元素是否连通，是很有实际意义的。比如计算机网络中两台不同计算机是否连通，社交网络中两个人是否有联系，一张图片中两个像素之间的联系等。
2. 判断一个集合中是否存在环
    > union 操作的时候，判断两个元素的父节点是否是一个，如果是，则存在环
3. 判断子集数

### 参考

- 算法导论-第21章:用于不想交集合的数据结构

### 练习题目

- 力扣1319.连通网络的操作次数

    基础的并查集

- 力扣547.朋友圈
- 力扣765.情侣牵手
- 力扣886.可能的二分法
